# Assignments 1 & 2 - Formal Languages and Compilers
## Project Description
This repository contains two implementations for Formal Languages and Compilers course:

1. DFA Minimization Algorithm - Based on Kozen's approach from "Automata and Computability"

2. Left Recursion Elimination - Implements Algorithm 4.19 from Aho et al.'s "Compilers: Principles, Techniques, and Tools"

## Students Information
Full Names: Ismael García Ceballos - Santiago Arellano López
Class Number: 5730

## Environment Specifications
Operating System: Windows 10/11

Programming Language: C++ (C++11 standard or higher)

Compiler: g++ (MinGW) or compatible C++ compiler

Terminal: PowerShell or Command Prompt

Development Tools: Visual Studio Code or Visual Studio

# Assignment 1: DFA Minimization Algorithm
## Implementation Instructions
Prerequisites
Ensure you have a C++ compiler installed (g++ from MinGW recommended)

Create an input file named input.txt in the same directory as the executable

## Compilation

* g++ main.cpp -o dfa_minimizer
## Execution

Using PowerShell:

* Get-Content input.txt | .\dfa_minimizer.exe

Using Command Prompt:

* dfa_minimizer.exe < input.txt
## Input File Format
The input file must follow this exact structure:

1               # Number of test cases
6               # Number of states in the DFA
a b             # Alphabet symbols (space-separated)
1 4 5           # Final states (space-separated)
0 1 2           # Transition table rows:
1 3 4           # - Each line represents a state
2 4 3           # - Columns correspond to alphabet symbols
3 5 5           #   in the order specified
4 5 5
5 5 5

## Expected Output
The program outputs equivalent state pairs in lexicographical order on a single line:

(2,3)
## Algorithm Explanation
This implementation follows the DFA minimization algorithm from Kozen's "Automata and Computability" (Lecture 14). The algorithm identifies equivalent states that can be collapsed to produce a minimal DFA.

## Algorithm Steps
Initialization Phase

Create a table of all unordered state pairs {p,q} where p < q

Initialize all pairs as unmarked

## Base Case Marking

Mark any pair {p,q} where one state is final and the other is non-final

These pairs are clearly non-equivalent since they differ on the empty string ε

## Recursive Marking

Repeatedly scan unmarked pairs {p,q}

For each unmarked pair, check if there exists any symbol a ∈ Σ such that the transition δ(p,a) and δ(q,a) leads to a marked pair

If such a symbol exists, mark {p,q} as non-equivalent

Continue until no new pairs can be marked in a complete pass

## Equivalent State Identification

After stabilization, unmarked pairs represent equivalent states

These states can be merged in the minimized automaton

## Key Properties
The algorithm correctly identifies all equivalent state pairs

The resulting DFA is minimal and unique up to isomorphism

All inaccessible states are assumed to be removed prior to minimization (as per assignment requirements)

# Assignment 2: Left Recursion Elimination
## Implementation Instructions
## Compilation

* g++ -std=c++11 -o left_recursion_eliminator main.cpp
Execution
Using PowerShell:

* Get-Content input.txt | .\left_recursion_eliminator.exe

Using Command Prompt:

* left_recursion_eliminator.exe < input.txt

## Input File Format

3               # Number of test cases
1               # Number of nonterminals
S -> Sa b       # Productions in format: <nonterminal> -> <alternatives>
2               # Number of nonterminals  
S -> Aa b       # Multiple productions for different nonterminals
A -> Ac Sd m
2
S -> Sa Ab
A -> Ac Sc c
Expected Output
text
S -> bA
A -> aA e

S -> Aa b
A -> bdB mB
B -> cB adB e

S -> AbB
A -> cC
B -> aB e
C -> cC bBcC e

### Algorithm Explanation

This implementation follows Algorithm 4.19 from Aho et al.'s "Compilers: Principles, Techniques, and Tools" for eliminating left recursion from context-free grammars.

## Algorithm Steps

Input Assumptions:

Grammar has no cycles (A ⟹⁺ A)

Grammar has no ε-productions (except those generated by the algorithm)

Capital letter S is the initial symbol

Nonterminals: uppercase letters, Terminals: lowercase letters

Symbol e represents the empty string (ε)

## Algorithm Procedure:

Order Nonterminals: Arrange nonterminals as A₁, A₂, ..., Aₙ with S first

Iterative Processing: For each i from 1 to n:

Replace Productions: For each production Aᵢ → Aⱼγ where j < i, replace with Aᵢ → δ₁γ | δ₂γ | ... | δₖγ where Aⱼ → δ₁ | δ₂ | ... | δₖ are all current Aⱼ-productions

Eliminate Immediate Left Recursion: For Aᵢ-productions, transform:

A → Aα₁ | Aα₂ | ... | Aαₘ | β₁ | β₂ | ... | βₙ
into:

A → β₁A' | β₂A' | ... | βₙA'
A' → α₁A' | α₂A' | ... | αₘA' | ε

## Key Features

Eliminates both immediate and indirect left recursion

Uses single uppercase letters for newly created nonterminals

Maintains grammar equivalence throughout transformation

Suitable for top-down parsing methods

## References

1. Kozen, D. C. (1997). Automata and Computability. Springer-Verlag. ISBN: 0387949070

2. Aho, A. V., Lam, M. S., Sethi, R., & Ullman, J. D. (2006). Compilers: Principles, Techniques, and Tools (2nd Edition). Addison-Wesley. ISBN: 0321486811
